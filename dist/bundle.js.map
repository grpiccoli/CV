{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa,YAAY,cAAc;AACzE,oDAAoD,UAAU;AAC9D,kCAAkC,eAAe,EAAE,OAAO;AAC1D,iCAAiC,gBAAgB,EAAE,qBAAqB,EAAE,UAAU;AACpF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,kEAAkE,iCAAiC;AACnG,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,4CAA4C,wBAAwB;AACpE,6CAA6C,uBAAuB,IAAI,wBAAwB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAyC;AAC7D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnHA;;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACNqB;AACiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAQ;AACpB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://grpiccoli-cv/./src/Timeline.ts","webpack://grpiccoli-cv/./src/main.scss?3362","webpack://grpiccoli-cv/webpack/bootstrap","webpack://grpiccoli-cv/webpack/runtime/define property getters","webpack://grpiccoli-cv/webpack/runtime/hasOwnProperty shorthand","webpack://grpiccoli-cv/webpack/runtime/make namespace object","webpack://grpiccoli-cv/./src/main.ts"],"sourcesContent":["export class Timeline {\n    parentElement;\n    constructor(parentElement) {\n        this.parentElement = parentElement;\n        this.configure();\n    }\n    // Computes the difference in months between two dates.\n    getMonthsDiff(start, end) {\n        return (end.getFullYear() - start.getFullYear()) * 12 +\n            (end.getMonth() - start.getMonth());\n    }\n    // Determines a base percentage position for an element date relative to a minimum date.\n    computeNumericPosition(elementDate, minDate, monthsDiff) {\n        const elementDiff = this.getMonthsDiff(minDate, elementDate);\n        return elementDiff / monthsDiff;\n    }\n    // Forms a CSS calc() expression based on the calculated percentage.\n    formatPosition(basePercent, dateWidth, isStart) {\n        // E.g. \"0.5 * (100% - 20px)\" with an offset to adjust the position.\n        const leftExpression = `${basePercent} * (100% - ${dateWidth * 2}px)`;\n        const offset = isStart ? ' - 0.3em' : ` + ${dateWidth}px + 0.3em`;\n        const leftValue = `calc(${leftExpression}${offset})`;\n        const computedValue = `${leftExpression} ${isStart ? '+' : '-'} ${dateWidth}px`;\n        return { leftValue, computedValue };\n    }\n    // Updates a timeline date element's position using helper functions.\n    updateElementPosition(timelineDate, minDate, dateWidth, monthsDiff) {\n        timelineDate.element.innerText = timelineDate.dateStr;\n        // Validate that the date is valid.\n        if (isNaN(timelineDate.elementDate.getTime())) {\n            throw new Error(\"Invalid date found for timeline element.\");\n        }\n        const basePercent = this.computeNumericPosition(timelineDate.elementDate, minDate, monthsDiff);\n        const { leftValue, computedValue } = this.formatPosition(basePercent, dateWidth, timelineDate.isStart);\n        timelineDate.element.style.left = leftValue;\n        return { leftValue, computedValue };\n    }\n    // Retrieves a TimelineDate from an HTML element.\n    getElementDate(element, isStart) {\n        const dataDate = element.dataset['date'];\n        const elementDate = dataDate ? new Date(dataDate) : new Date();\n        const dateStr = elementDate.toLocaleDateString('en-NZ', { month: 'short', year: 'numeric' });\n        return { element, dateStr, elementDate, isStart };\n    }\n    // Factory method to get a TimelineElements group from a timeline container.\n    createTimelineElement(dateElem) {\n        const startElement = dateElem.querySelector(\".timeline-date.start\");\n        const endElement = dateElem.querySelector(\".timeline-date.end\");\n        const blockElement = dateElem.querySelector('.timeline-block');\n        if (!startElement || !endElement || !blockElement) {\n            throw new Error(\"Missing timeline sub-element in: \" + dateElem.outerHTML);\n        }\n        return {\n            start: this.getElementDate(startElement, true),\n            end: this.getElementDate(endElement, false),\n            block: blockElement\n        };\n    }\n    // Computes common metrics required for setting up timeline elements.\n    computeTimelineMetrics(dates) {\n        let dateWidth;\n        let minDate;\n        let maxDate;\n        const timelines = [];\n        dates.forEach((dateElem) => {\n            const timeline = this.createTimelineElement(dateElem);\n            // Only compute width and baseline dates once.\n            if (dateWidth === undefined) {\n                const computedStyle = window.getComputedStyle(timeline.start.element);\n                const widthValue = parseInt(computedStyle.width, 10);\n                if (isNaN(widthValue)) {\n                    throw new Error(\"Unable to parse width from computed style.\");\n                }\n                dateWidth = widthValue;\n                minDate = timeline.start.elementDate;\n                maxDate = timeline.end.elementDate;\n            }\n            else {\n                if (timeline.start.elementDate < minDate) {\n                    minDate = timeline.start.elementDate;\n                }\n                if (timeline.end.elementDate > maxDate) {\n                    maxDate = timeline.end.elementDate;\n                }\n            }\n            timelines.push(timeline);\n        });\n        if (dateWidth === undefined || minDate === undefined || maxDate === undefined) {\n            throw new Error(\"Could not compute timeline metrics\");\n        }\n        return { dateWidth, minDate, maxDate, timelines };\n    }\n    // Sets the CSS for the block element based on the start and end timeline dates.\n    configureTimelineBlock(timeline, minDate, dateWidth, monthsDiff) {\n        const startData = this.updateElementPosition(timeline.start, minDate, dateWidth, monthsDiff);\n        const endData = this.updateElementPosition(timeline.end, minDate, dateWidth, monthsDiff);\n        timeline.block.style.left = `calc(${startData.computedValue})`;\n        timeline.block.style.width = `calc(${endData.computedValue} - ${startData.computedValue})`;\n    }\n    // Main configuration method wraps all logic in a try/catch for robustness.\n    configure() {\n        const dates = this.parentElement.querySelectorAll('.timeline');\n        if (dates.length === 0)\n            return;\n        try {\n            const { dateWidth, minDate, maxDate, timelines } = this.computeTimelineMetrics(dates);\n            const monthsDiff = this.getMonthsDiff(minDate, maxDate) || 1;\n            timelines.forEach((timeline) => {\n                this.configureTimelineBlock(timeline, minDate, dateWidth, monthsDiff);\n            });\n        }\n        catch (error) {\n            console.error(\"Timeline configuration error: \", error);\n        }\n    }\n}\n","// extracted by mini-css-extract-plugin\nexport {};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import './main.scss';\nimport { Timeline } from './Timeline';\n/**\n * Initializes the toggle logic for the print menu.\n */\nconst togglePrintMenu = () => {\n    const printToggle = document.getElementById('print-toggle');\n    const printMenu = document.getElementById('print-menu');\n    if (!printToggle || !printMenu)\n        return;\n    printToggle.addEventListener('click', () => {\n        const display = printMenu.style.display;\n        printMenu.style.display = (!display || display === 'none') ? 'block' : 'none';\n    });\n};\n/**\n * Initializes the section toggles.\n * Each checkbox is wired to show or hide its associated section.\n */\nconst initSectionToggles = () => {\n    const sections = {\n        'toggle-about': document.getElementById('about'),\n        'toggle-experience': document.getElementById('experience'),\n        'toggle-certifications': document.getElementById('certifications'),\n        'toggle-education': document.getElementById('education'),\n        'toggle-academic': document.getElementById('academic-experience'),\n        'toggle-publications': document.getElementById('publications'),\n        'toggle-references': document.getElementById('references')\n    };\n    Object.keys(sections).forEach((toggleId) => {\n        const checkbox = document.getElementById(toggleId);\n        const sectionElement = sections[toggleId];\n        if (checkbox && sectionElement) {\n            checkbox.addEventListener('change', function () {\n                sectionElement.style.display = this.checked ? '' : 'none';\n            });\n        }\n    });\n};\n/**\n * Initializes the navigation toggle logic.\n */\nconst initNavigationToggle = () => {\n    const navToggle = document.getElementById('nav-toggle');\n    const navMenu = document.getElementById('nav-menu');\n    if (navToggle && navMenu) {\n        navToggle.addEventListener('click', () => {\n            navMenu.classList.toggle('open');\n        });\n    }\n};\n/**\n * Applies timeline logic to each selected timeline container.\n * Uses the Timeline class for encapsulation.\n */\nconst initTimelines = () => {\n    document.querySelectorAll(\"#experience, #academic-experience\").forEach((element) => {\n        new Timeline(element);\n    });\n};\n/**\n * Main initialization on DOM content loaded.\n */\nconst init = () => {\n    togglePrintMenu();\n    initSectionToggles();\n    initNavigationToggle();\n    initTimelines();\n};\ndocument.addEventListener('DOMContentLoaded', init);\n"],"names":[],"sourceRoot":""}